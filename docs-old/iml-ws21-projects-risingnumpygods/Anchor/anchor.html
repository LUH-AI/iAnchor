<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>iml-ws21-projects-risingnumpygods.Anchor.anchor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>iml-ws21-projects-risingnumpygods.Anchor.anchor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging

from Anchor.visualizer import Visualizer

logging.basicConfig(level=logging.INFO)
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Callable, Optional, Protocol, Tuple, Union

import numpy as np
from ConfigSpace import ConfigurationSpace
from ConfigSpace.hyperparameters import UniformIntegerHyperparameter
from skimage.segmentation import quickshift
from smac.facade.smac_bb_facade import SMAC4BB
from smac.scenario.scenario import Scenario

from Anchor.bandit import KL_LUCB
from Anchor.candidate import AnchorCandidate
from Anchor.sampler import Sampler, Tasktype

from .visualizer import Visualizer


@dataclass()
class Anchor:
    &#34;&#34;&#34;
    Approach to explain predictions of a blackbox model using anchors.
    It returns the explaination with a precision and coverage score.

    More details can be found in the following paper:
    https://homes.cs.washington.edu/~marcotcr/aaai18.pdf
    &#34;&#34;&#34;

    tasktype: Tasktype
    sampler: Sampler = field(init=False)
    visualizer: Visualizer = field(init=False)
    verbose: bool = False
    coverage_data: np.array = field(init=False)

    def __post_init__(self):
        logging.basicConfig(format=&#34;%(levelname)s:%(message)s&#34;, level=logging.DEBUG)

    def explain_instance(
        self,
        input: any,
        predict_fn: Callable[[any], np.array],
        method: str = &#34;greedy&#34;,
        task_specific: dict = None,
        method_specific: dict = None,
        num_coverage_samples: int = 10000,
        epsilon: float = 0.1,
        delta: float = 0.1,
        batch_size: int = 16,
        verbose=False,
        seed=69,
    ):
        &#34;&#34;&#34;
        Main entrance point to explain an instance.

        Args:
            input (Any): The instance to explain - can be an image, data row or text.
            predict_fn (Callable): A function that returns the class prediction for a sample (can be wrapped with provided wrapper functions).
            method (String): Defines the optimization function. Can be (``greedy``), (``beam``) or (``smac``).
            dataset (np.array): The dataset for permutation. Could be images for image task or tabular data for tabular task.
            task_specific (dict): Task specific arguments. For tabular this includes the (``column_names``) and (``dataset``) argument. For images it includes (``dataset``).
            method_specific (dict): Optimization method specific arguments. For Beam Search this includes (``beam_size``) and (``desired_confidence``). 
                For greedy this includes (``desired_confidence``). For Smac this includes (``run_time``) in seconds and (``optim``). 
                Optim is a function with the signature AnchorCandiate -&gt; float that will be minimized.
            num_coverage_samples (int): Number of coverage samples
            desired_confidence (float): desired precision confidence for the anchor.
            epsilon (float)
            batch_size (int)
            verbose (bool)

        Returns:
            exp (AnchorCandidate): The explanation of the original instance.

        &#34;&#34;&#34;
        self.seed = seed
        np.random.seed(seed)

        # in case args are empty
        if task_specific is None:
            task_specific = {}

        if method_specific is None:
            method_specific = {}

        self.kl_lucb = KL_LUCB(
            eps=epsilon, delta=delta, batch_size=batch_size, verbose=verbose
        )
        self.sampler = Sampler.create(self.tasktype, input, predict_fn, task_specific)

        self.batch_size = batch_size
        self.delta = delta
        logging.info(&#34; Start Sampling&#34;)
        _, self.coverage_data = self.sampler.sample(
            AnchorCandidate(feature_mask=[]), num_coverage_samples, False
        )
        exp = AnchorCandidate(feature_mask=[])
        if method == &#34;greedy&#34;:
            logging.info(&#34; Start Greedy Search&#34;)
            exp = self.__greedy_anchor(**method_specific)
        elif method == &#34;beam&#34;:
            logging.info(&#34; Start Beam Search&#34;)
            exp = self.__beam_anchor(**method_specific)
        elif method == &#34;smac&#34;:
            logging.info(&#34; Start SMAC Search&#34;)

            exp = self.__smac_anchor(**method_specific)

        return exp

    def visualize(self, anchor: AnchorCandidate, instance: np.ndarray):
        &#34;&#34;&#34;
        Visualized the instance given the anchor.

        Args:
            anchor (AnchorCandidate): Anchor (usually result of explain_instance)
            instance (np.ndarray): Instance that shall be explained by the anchor.
        &#34;&#34;&#34;

        # as text sampler has no self.features
        try:
            features = self.sampler.features
        except AttributeError:
            features = None

        return Visualizer.create(self.tasktype).visualize(anchor, instance, features)

    def generate_candidates(
        self, prev_anchors: list[AnchorCandidate], coverage_min: float
    ) -&gt; list[AnchorCandidate]:
        &#34;&#34;&#34;
        Generates new anchor candidates by adding a new unseen feature
        to each previous anchor feature mask.

        Args:
            prev_anchors (list[AnchorCandidate]): previous anchors.
            coverage_min (float): min_coverage an anchor must have.

        Returns:
            list[AnchorCandidate]: new anchor candidates
        &#34;&#34;&#34;
        new_candidates: list[AnchorCandidate] = []
        # iterate over possible features or predicates
        for feature in range(self.sampler.num_features):
            # check if we have no prev anchors and create a complete new set
            if len(prev_anchors) == 0:
                nc = AnchorCandidate(feature_mask=[feature])
                new_candidates.append(nc)

            for anchor in prev_anchors:
                # check if feature already in the feature_mask of the anchor
                if feature in anchor.feature_mask:
                    continue

                # append new feature to candidate
                tmp = anchor.feature_mask.copy()
                tmp.append(feature)

                nc = AnchorCandidate(feature_mask=tmp)
                nc.coverage = self.__calculate_coverage(nc)
                if nc.coverage &gt;= coverage_min:
                    new_candidates.append(nc)

        return new_candidates

    def __calculate_coverage(self, anchor: AnchorCandidate) -&gt; float:
        &#34;&#34;&#34;
        Calculates the coverage for an given anchor.

        Args:
            anchor (AnchorCandidate): Anchor for which the coverage shall be calculated.

        Returns:
            float: Coverage
        &#34;&#34;&#34;
        included_samples = 0
        for mask in self.coverage_data:  # replace with numpy only
            # check if mask positive samples are included in the feature_mask of the anchor
            if np.all(np.isin(anchor.feature_mask, np.where(mask == 1)), axis=0):
                included_samples += 1

        return included_samples / self.coverage_data.shape[0]

    def __check_valid_candidate(
        self,
        candidate: AnchorCandidate,
        beam_size: int,
        sample_count: int,
        dconf: float,
        delta: float = 0.1,
        eps_stop: float = 0.05,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Checks if an candidate fullfills precision boundary constraints
        &#34;&#34;&#34;
        prec = candidate.precision
        beta = np.log(1.0 / (delta / (1 + (beam_size - 1) * self.sampler.num_features)))

        lb = KL_LUCB.dlow_bernoulli(prec, beta / max(candidate.n_samples, 1))
        ub = KL_LUCB.dup_bernoulli(prec, beta / max(candidate.n_samples, 1))

        while (prec &gt;= dconf and lb &lt; dconf - eps_stop) or (
            prec &lt; dconf and ub &gt;= dconf + eps_stop
        ):
            nc, _ = self.sampler.sample(candidate, sample_count)
            prec = nc.precision
            lb = KL_LUCB.dlow_bernoulli(prec, beta / nc.n_samples)

            ub = KL_LUCB.dup_bernoulli(prec, beta / nc.n_samples)

        return prec &gt;= dconf and lb &gt; dconf - eps_stop

    def __greedy_anchor(
        self, desired_confidence: float = 1, min_coverage: float = 0.2,
    ):
        &#34;&#34;&#34;
        Greedy Approach to calculate the shortest anchor, which fullfills the precision constraint EQ3.

        Args:
            desired_confidence (float): desired approximated precision
            min_coverage (float): min coverage an anchor needs to be accepted

        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;
        candidates = self.generate_candidates([], min_coverage)
        anchor = self.kl_lucb.get_best_candidates(candidates, self.sampler, 1)[0]

        while not self.__check_valid_candidate(
            anchor, 1, self.batch_size, desired_confidence, self.delta
        ):
            candidates = self.generate_candidates([anchor], min_coverage)

            # no more candiates return the best one so far
            if len(candidates) == 0:
                break

            anchor = self.kl_lucb.get_best_candidates(candidates, self.sampler, 1)[0]

        return anchor

    def __beam_anchor(
        self, desired_confidence: float, beam_size: int,
    ) -&gt; AnchorCandidate:
        &#34;&#34;&#34;
        Beam search algorithm to find anchor.

        Args:
            desired_confidence (float): Desired confidence before stopping.
            beam_size (int): Beam size

        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;
        max_anchor_size = self.sampler.num_features
        current_anchor_size = 1
        best_of_size = {0: []}  # A0
        best_candidate = AnchorCandidate([])  # A*

        while current_anchor_size &lt; max_anchor_size:
            # Generate candidates
            candidates = self.generate_candidates(
                best_of_size[current_anchor_size - 1], best_candidate.coverage,
            )

            # no more candiates return best one so far
            if len(candidates) == 0:
                break

            best_candidates = self.kl_lucb.get_best_candidates(
                candidates, self.sampler, min(beam_size, len(candidates))
            )

            best_of_size[current_anchor_size] = best_candidates

            # update best candiate when its valid and has a better
            # coverage.
            for c in best_candidates:
                if (
                    self.__check_valid_candidate(
                        c,
                        beam_size=beam_size,
                        sample_count=self.batch_size,
                        dconf=desired_confidence,
                        delta=self.delta,
                    )
                    and c.coverage &gt; best_candidate.coverage
                ):
                    best_candidate = c

            current_anchor_size += 1

        return best_candidate

    def __smac_anchor(
        self, run_time: int, optim: Callable[[AnchorCandidate], float] = None
    ) -&gt; AnchorCandidate:
        &#34;&#34;&#34;
        Utilites smac to find an anchor.

        Args:
            run_time (int): Amount of wallclock time to run the optimization for.
        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;

        self.smac_optim_func = optim if optim is not None else None

        # create config space
        configspace = ConfigurationSpace()

        # mask the possible features
        for i in range(self.sampler.num_features):
            configspace.add_hyperparameter(UniformIntegerHyperparameter(str(i), 0, 1))

        # create Szenario
        scenario = Scenario(
            {
                &#34;run_obj&#34;: &#34;quality&#34;,
                &#34;wallclock_limit&#34;: run_time,
                &#34;cs&#34;: configspace,
                &#34;deterministic&#34;: &#34;true&#34;,  # each config gets evaluated once, other option would be to track candidates and average precision / coverage
            }
        )

        # create optimizer
        smac = SMAC4BB(
            scenario=scenario,
            tae_runner=self.smac_optimize,
            rng=np.random.RandomState(self.seed),
        )
        best_mask = smac.optimize()

        feature_mask = [int(f_idx) for f_idx, mv in best_mask.items() if mv]
        stats = smac.runhistory.data[
            next(reversed(smac.runhistory.data))
        ].additional_info

        return AnchorCandidate(
            feature_mask=feature_mask,
            precision=stats[&#34;precision&#34;],
            coverage=stats[&#34;coverage&#34;],
        )

    def smac_optimize(self, config):
        &#34;&#34;&#34;
        Main bayesian optimization loop for smac.

        Args:
            config (Configspace): Current feature configuration to be evalauted.
        &#34;&#34;&#34;
        feature_mask = [int(f_idx) for f_idx, mv in config.items() if mv]

        # create candidate from config which is the feature mask to evaluate
        candidate = AnchorCandidate(feature_mask)

        # calculate expected precision
        candidate, _ = self.sampler.sample(candidate, self.batch_size)
        candidate.coverage = self.__calculate_coverage(candidate)

        info = {&#34;precision&#34;: candidate.precision, &#34;coverage&#34;: candidate.coverage}

        if self.smac_optim_func is not None:
            return self.smac_optim_func(candidate), info
        else:
            return (
                (
                    (1 - candidate.precision)
                    + (len(candidate.feature_mask) / self.sampler.num_features)
                )
                / 2,
                info,
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor"><code class="flex name class">
<span>class <span class="ident">Anchor</span></span>
<span>(</span><span>tasktype: Anchor.sampler.Tasktype, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Approach to explain predictions of a blackbox model using anchors.
It returns the explaination with a precision and coverage score.</p>
<p>More details can be found in the following paper:
<a href="https://homes.cs.washington.edu/~marcotcr/aaai18.pdf">https://homes.cs.washington.edu/~marcotcr/aaai18.pdf</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass()
class Anchor:
    &#34;&#34;&#34;
    Approach to explain predictions of a blackbox model using anchors.
    It returns the explaination with a precision and coverage score.

    More details can be found in the following paper:
    https://homes.cs.washington.edu/~marcotcr/aaai18.pdf
    &#34;&#34;&#34;

    tasktype: Tasktype
    sampler: Sampler = field(init=False)
    visualizer: Visualizer = field(init=False)
    verbose: bool = False
    coverage_data: np.array = field(init=False)

    def __post_init__(self):
        logging.basicConfig(format=&#34;%(levelname)s:%(message)s&#34;, level=logging.DEBUG)

    def explain_instance(
        self,
        input: any,
        predict_fn: Callable[[any], np.array],
        method: str = &#34;greedy&#34;,
        task_specific: dict = None,
        method_specific: dict = None,
        num_coverage_samples: int = 10000,
        epsilon: float = 0.1,
        delta: float = 0.1,
        batch_size: int = 16,
        verbose=False,
        seed=69,
    ):
        &#34;&#34;&#34;
        Main entrance point to explain an instance.

        Args:
            input (Any): The instance to explain - can be an image, data row or text.
            predict_fn (Callable): A function that returns the class prediction for a sample (can be wrapped with provided wrapper functions).
            method (String): Defines the optimization function. Can be (``greedy``), (``beam``) or (``smac``).
            dataset (np.array): The dataset for permutation. Could be images for image task or tabular data for tabular task.
            task_specific (dict): Task specific arguments. For tabular this includes the (``column_names``) and (``dataset``) argument. For images it includes (``dataset``).
            method_specific (dict): Optimization method specific arguments. For Beam Search this includes (``beam_size``) and (``desired_confidence``). 
                For greedy this includes (``desired_confidence``). For Smac this includes (``run_time``) in seconds and (``optim``). 
                Optim is a function with the signature AnchorCandiate -&gt; float that will be minimized.
            num_coverage_samples (int): Number of coverage samples
            desired_confidence (float): desired precision confidence for the anchor.
            epsilon (float)
            batch_size (int)
            verbose (bool)

        Returns:
            exp (AnchorCandidate): The explanation of the original instance.

        &#34;&#34;&#34;
        self.seed = seed
        np.random.seed(seed)

        # in case args are empty
        if task_specific is None:
            task_specific = {}

        if method_specific is None:
            method_specific = {}

        self.kl_lucb = KL_LUCB(
            eps=epsilon, delta=delta, batch_size=batch_size, verbose=verbose
        )
        self.sampler = Sampler.create(self.tasktype, input, predict_fn, task_specific)

        self.batch_size = batch_size
        self.delta = delta
        logging.info(&#34; Start Sampling&#34;)
        _, self.coverage_data = self.sampler.sample(
            AnchorCandidate(feature_mask=[]), num_coverage_samples, False
        )
        exp = AnchorCandidate(feature_mask=[])
        if method == &#34;greedy&#34;:
            logging.info(&#34; Start Greedy Search&#34;)
            exp = self.__greedy_anchor(**method_specific)
        elif method == &#34;beam&#34;:
            logging.info(&#34; Start Beam Search&#34;)
            exp = self.__beam_anchor(**method_specific)
        elif method == &#34;smac&#34;:
            logging.info(&#34; Start SMAC Search&#34;)

            exp = self.__smac_anchor(**method_specific)

        return exp

    def visualize(self, anchor: AnchorCandidate, instance: np.ndarray):
        &#34;&#34;&#34;
        Visualized the instance given the anchor.

        Args:
            anchor (AnchorCandidate): Anchor (usually result of explain_instance)
            instance (np.ndarray): Instance that shall be explained by the anchor.
        &#34;&#34;&#34;

        # as text sampler has no self.features
        try:
            features = self.sampler.features
        except AttributeError:
            features = None

        return Visualizer.create(self.tasktype).visualize(anchor, instance, features)

    def generate_candidates(
        self, prev_anchors: list[AnchorCandidate], coverage_min: float
    ) -&gt; list[AnchorCandidate]:
        &#34;&#34;&#34;
        Generates new anchor candidates by adding a new unseen feature
        to each previous anchor feature mask.

        Args:
            prev_anchors (list[AnchorCandidate]): previous anchors.
            coverage_min (float): min_coverage an anchor must have.

        Returns:
            list[AnchorCandidate]: new anchor candidates
        &#34;&#34;&#34;
        new_candidates: list[AnchorCandidate] = []
        # iterate over possible features or predicates
        for feature in range(self.sampler.num_features):
            # check if we have no prev anchors and create a complete new set
            if len(prev_anchors) == 0:
                nc = AnchorCandidate(feature_mask=[feature])
                new_candidates.append(nc)

            for anchor in prev_anchors:
                # check if feature already in the feature_mask of the anchor
                if feature in anchor.feature_mask:
                    continue

                # append new feature to candidate
                tmp = anchor.feature_mask.copy()
                tmp.append(feature)

                nc = AnchorCandidate(feature_mask=tmp)
                nc.coverage = self.__calculate_coverage(nc)
                if nc.coverage &gt;= coverage_min:
                    new_candidates.append(nc)

        return new_candidates

    def __calculate_coverage(self, anchor: AnchorCandidate) -&gt; float:
        &#34;&#34;&#34;
        Calculates the coverage for an given anchor.

        Args:
            anchor (AnchorCandidate): Anchor for which the coverage shall be calculated.

        Returns:
            float: Coverage
        &#34;&#34;&#34;
        included_samples = 0
        for mask in self.coverage_data:  # replace with numpy only
            # check if mask positive samples are included in the feature_mask of the anchor
            if np.all(np.isin(anchor.feature_mask, np.where(mask == 1)), axis=0):
                included_samples += 1

        return included_samples / self.coverage_data.shape[0]

    def __check_valid_candidate(
        self,
        candidate: AnchorCandidate,
        beam_size: int,
        sample_count: int,
        dconf: float,
        delta: float = 0.1,
        eps_stop: float = 0.05,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Checks if an candidate fullfills precision boundary constraints
        &#34;&#34;&#34;
        prec = candidate.precision
        beta = np.log(1.0 / (delta / (1 + (beam_size - 1) * self.sampler.num_features)))

        lb = KL_LUCB.dlow_bernoulli(prec, beta / max(candidate.n_samples, 1))
        ub = KL_LUCB.dup_bernoulli(prec, beta / max(candidate.n_samples, 1))

        while (prec &gt;= dconf and lb &lt; dconf - eps_stop) or (
            prec &lt; dconf and ub &gt;= dconf + eps_stop
        ):
            nc, _ = self.sampler.sample(candidate, sample_count)
            prec = nc.precision
            lb = KL_LUCB.dlow_bernoulli(prec, beta / nc.n_samples)

            ub = KL_LUCB.dup_bernoulli(prec, beta / nc.n_samples)

        return prec &gt;= dconf and lb &gt; dconf - eps_stop

    def __greedy_anchor(
        self, desired_confidence: float = 1, min_coverage: float = 0.2,
    ):
        &#34;&#34;&#34;
        Greedy Approach to calculate the shortest anchor, which fullfills the precision constraint EQ3.

        Args:
            desired_confidence (float): desired approximated precision
            min_coverage (float): min coverage an anchor needs to be accepted

        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;
        candidates = self.generate_candidates([], min_coverage)
        anchor = self.kl_lucb.get_best_candidates(candidates, self.sampler, 1)[0]

        while not self.__check_valid_candidate(
            anchor, 1, self.batch_size, desired_confidence, self.delta
        ):
            candidates = self.generate_candidates([anchor], min_coverage)

            # no more candiates return the best one so far
            if len(candidates) == 0:
                break

            anchor = self.kl_lucb.get_best_candidates(candidates, self.sampler, 1)[0]

        return anchor

    def __beam_anchor(
        self, desired_confidence: float, beam_size: int,
    ) -&gt; AnchorCandidate:
        &#34;&#34;&#34;
        Beam search algorithm to find anchor.

        Args:
            desired_confidence (float): Desired confidence before stopping.
            beam_size (int): Beam size

        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;
        max_anchor_size = self.sampler.num_features
        current_anchor_size = 1
        best_of_size = {0: []}  # A0
        best_candidate = AnchorCandidate([])  # A*

        while current_anchor_size &lt; max_anchor_size:
            # Generate candidates
            candidates = self.generate_candidates(
                best_of_size[current_anchor_size - 1], best_candidate.coverage,
            )

            # no more candiates return best one so far
            if len(candidates) == 0:
                break

            best_candidates = self.kl_lucb.get_best_candidates(
                candidates, self.sampler, min(beam_size, len(candidates))
            )

            best_of_size[current_anchor_size] = best_candidates

            # update best candiate when its valid and has a better
            # coverage.
            for c in best_candidates:
                if (
                    self.__check_valid_candidate(
                        c,
                        beam_size=beam_size,
                        sample_count=self.batch_size,
                        dconf=desired_confidence,
                        delta=self.delta,
                    )
                    and c.coverage &gt; best_candidate.coverage
                ):
                    best_candidate = c

            current_anchor_size += 1

        return best_candidate

    def __smac_anchor(
        self, run_time: int, optim: Callable[[AnchorCandidate], float] = None
    ) -&gt; AnchorCandidate:
        &#34;&#34;&#34;
        Utilites smac to find an anchor.

        Args:
            run_time (int): Amount of wallclock time to run the optimization for.
        Returns:
            AnchorCandidate: best found anchor
        &#34;&#34;&#34;

        self.smac_optim_func = optim if optim is not None else None

        # create config space
        configspace = ConfigurationSpace()

        # mask the possible features
        for i in range(self.sampler.num_features):
            configspace.add_hyperparameter(UniformIntegerHyperparameter(str(i), 0, 1))

        # create Szenario
        scenario = Scenario(
            {
                &#34;run_obj&#34;: &#34;quality&#34;,
                &#34;wallclock_limit&#34;: run_time,
                &#34;cs&#34;: configspace,
                &#34;deterministic&#34;: &#34;true&#34;,  # each config gets evaluated once, other option would be to track candidates and average precision / coverage
            }
        )

        # create optimizer
        smac = SMAC4BB(
            scenario=scenario,
            tae_runner=self.smac_optimize,
            rng=np.random.RandomState(self.seed),
        )
        best_mask = smac.optimize()

        feature_mask = [int(f_idx) for f_idx, mv in best_mask.items() if mv]
        stats = smac.runhistory.data[
            next(reversed(smac.runhistory.data))
        ].additional_info

        return AnchorCandidate(
            feature_mask=feature_mask,
            precision=stats[&#34;precision&#34;],
            coverage=stats[&#34;coverage&#34;],
        )

    def smac_optimize(self, config):
        &#34;&#34;&#34;
        Main bayesian optimization loop for smac.

        Args:
            config (Configspace): Current feature configuration to be evalauted.
        &#34;&#34;&#34;
        feature_mask = [int(f_idx) for f_idx, mv in config.items() if mv]

        # create candidate from config which is the feature mask to evaluate
        candidate = AnchorCandidate(feature_mask)

        # calculate expected precision
        candidate, _ = self.sampler.sample(candidate, self.batch_size)
        candidate.coverage = self.__calculate_coverage(candidate)

        info = {&#34;precision&#34;: candidate.precision, &#34;coverage&#34;: candidate.coverage}

        if self.smac_optim_func is not None:
            return self.smac_optim_func(candidate), info
        else:
            return (
                (
                    (1 - candidate.precision)
                    + (len(candidate.feature_mask) / self.sampler.num_features)
                )
                / 2,
                info,
            )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.coverage_data"><code class="name">var <span class="ident">coverage_data</span> : <built-in function array></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.sampler"><code class="name">var <span class="ident">sampler</span> : Anchor.sampler.Sampler</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.tasktype"><code class="name">var <span class="ident">tasktype</span> : Anchor.sampler.Tasktype</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.verbose"><code class="name">var <span class="ident">verbose</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualizer"><code class="name">var <span class="ident">visualizer</span> : iml-ws21-projects-risingnumpygods.Anchor.visualizer.Visualizer</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.explain_instance"><code class="name flex">
<span>def <span class="ident">explain_instance</span></span>(<span>self, input: <built-in function any>, predict_fn: Callable[[<built-in function any>], <built-in function array>], method: str = 'greedy', task_specific: dict = None, method_specific: dict = None, num_coverage_samples: int = 10000, epsilon: float = 0.1, delta: float = 0.1, batch_size: int = 16, verbose=False, seed=69)</span>
</code></dt>
<dd>
<div class="desc"><p>Main entrance point to explain an instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Any</code></dt>
<dd>The instance to explain - can be an image, data row or text.</dd>
<dt><strong><code>predict_fn</code></strong> :&ensp;<code>Callable</code></dt>
<dd>A function that returns the class prediction for a sample (can be wrapped with provided wrapper functions).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>String</code></dt>
<dd>Defines the optimization function. Can be (<code>greedy</code>), (<code>beam</code>) or (<code>smac</code>).</dd>
<dt><strong><code>dataset</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The dataset for permutation. Could be images for image task or tabular data for tabular task.</dd>
<dt><strong><code>task_specific</code></strong> :&ensp;<code>dict</code></dt>
<dd>Task specific arguments. For tabular this includes the (<code>column_names</code>) and (<code>dataset</code>) argument. For images it includes (<code>dataset</code>).</dd>
<dt><strong><code>method_specific</code></strong> :&ensp;<code>dict</code></dt>
<dd>Optimization method specific arguments. For Beam Search this includes (<code>beam_size</code>) and (<code>desired_confidence</code>).
For greedy this includes (<code>desired_confidence</code>). For Smac this includes (<code>run_time</code>) in seconds and (<code>optim</code>).
Optim is a function with the signature AnchorCandiate -&gt; float that will be minimized.</dd>
<dt><strong><code>num_coverage_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of coverage samples</dd>
<dt><strong><code>desired_confidence</code></strong> :&ensp;<code>float</code></dt>
<dd>desired precision confidence for the anchor.</dd>
</dl>
<p>epsilon (float)
batch_size (int)
verbose (bool)</p>
<h2 id="returns">Returns</h2>
<p>exp (AnchorCandidate): The explanation of the original instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explain_instance(
    self,
    input: any,
    predict_fn: Callable[[any], np.array],
    method: str = &#34;greedy&#34;,
    task_specific: dict = None,
    method_specific: dict = None,
    num_coverage_samples: int = 10000,
    epsilon: float = 0.1,
    delta: float = 0.1,
    batch_size: int = 16,
    verbose=False,
    seed=69,
):
    &#34;&#34;&#34;
    Main entrance point to explain an instance.

    Args:
        input (Any): The instance to explain - can be an image, data row or text.
        predict_fn (Callable): A function that returns the class prediction for a sample (can be wrapped with provided wrapper functions).
        method (String): Defines the optimization function. Can be (``greedy``), (``beam``) or (``smac``).
        dataset (np.array): The dataset for permutation. Could be images for image task or tabular data for tabular task.
        task_specific (dict): Task specific arguments. For tabular this includes the (``column_names``) and (``dataset``) argument. For images it includes (``dataset``).
        method_specific (dict): Optimization method specific arguments. For Beam Search this includes (``beam_size``) and (``desired_confidence``). 
            For greedy this includes (``desired_confidence``). For Smac this includes (``run_time``) in seconds and (``optim``). 
            Optim is a function with the signature AnchorCandiate -&gt; float that will be minimized.
        num_coverage_samples (int): Number of coverage samples
        desired_confidence (float): desired precision confidence for the anchor.
        epsilon (float)
        batch_size (int)
        verbose (bool)

    Returns:
        exp (AnchorCandidate): The explanation of the original instance.

    &#34;&#34;&#34;
    self.seed = seed
    np.random.seed(seed)

    # in case args are empty
    if task_specific is None:
        task_specific = {}

    if method_specific is None:
        method_specific = {}

    self.kl_lucb = KL_LUCB(
        eps=epsilon, delta=delta, batch_size=batch_size, verbose=verbose
    )
    self.sampler = Sampler.create(self.tasktype, input, predict_fn, task_specific)

    self.batch_size = batch_size
    self.delta = delta
    logging.info(&#34; Start Sampling&#34;)
    _, self.coverage_data = self.sampler.sample(
        AnchorCandidate(feature_mask=[]), num_coverage_samples, False
    )
    exp = AnchorCandidate(feature_mask=[])
    if method == &#34;greedy&#34;:
        logging.info(&#34; Start Greedy Search&#34;)
        exp = self.__greedy_anchor(**method_specific)
    elif method == &#34;beam&#34;:
        logging.info(&#34; Start Beam Search&#34;)
        exp = self.__beam_anchor(**method_specific)
    elif method == &#34;smac&#34;:
        logging.info(&#34; Start SMAC Search&#34;)

        exp = self.__smac_anchor(**method_specific)

    return exp</code></pre>
</details>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.generate_candidates"><code class="name flex">
<span>def <span class="ident">generate_candidates</span></span>(<span>self, prev_anchors: list, coverage_min: float) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Generates new anchor candidates by adding a new unseen feature
to each previous anchor feature mask.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prev_anchors</code></strong> :&ensp;<code>list[AnchorCandidate]</code></dt>
<dd>previous anchors.</dd>
<dt><strong><code>coverage_min</code></strong> :&ensp;<code>float</code></dt>
<dd>min_coverage an anchor must have.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[AnchorCandidate]</code></dt>
<dd>new anchor candidates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_candidates(
    self, prev_anchors: list[AnchorCandidate], coverage_min: float
) -&gt; list[AnchorCandidate]:
    &#34;&#34;&#34;
    Generates new anchor candidates by adding a new unseen feature
    to each previous anchor feature mask.

    Args:
        prev_anchors (list[AnchorCandidate]): previous anchors.
        coverage_min (float): min_coverage an anchor must have.

    Returns:
        list[AnchorCandidate]: new anchor candidates
    &#34;&#34;&#34;
    new_candidates: list[AnchorCandidate] = []
    # iterate over possible features or predicates
    for feature in range(self.sampler.num_features):
        # check if we have no prev anchors and create a complete new set
        if len(prev_anchors) == 0:
            nc = AnchorCandidate(feature_mask=[feature])
            new_candidates.append(nc)

        for anchor in prev_anchors:
            # check if feature already in the feature_mask of the anchor
            if feature in anchor.feature_mask:
                continue

            # append new feature to candidate
            tmp = anchor.feature_mask.copy()
            tmp.append(feature)

            nc = AnchorCandidate(feature_mask=tmp)
            nc.coverage = self.__calculate_coverage(nc)
            if nc.coverage &gt;= coverage_min:
                new_candidates.append(nc)

    return new_candidates</code></pre>
</details>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.smac_optimize"><code class="name flex">
<span>def <span class="ident">smac_optimize</span></span>(<span>self, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Main bayesian optimization loop for smac.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Configspace</code></dt>
<dd>Current feature configuration to be evalauted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smac_optimize(self, config):
    &#34;&#34;&#34;
    Main bayesian optimization loop for smac.

    Args:
        config (Configspace): Current feature configuration to be evalauted.
    &#34;&#34;&#34;
    feature_mask = [int(f_idx) for f_idx, mv in config.items() if mv]

    # create candidate from config which is the feature mask to evaluate
    candidate = AnchorCandidate(feature_mask)

    # calculate expected precision
    candidate, _ = self.sampler.sample(candidate, self.batch_size)
    candidate.coverage = self.__calculate_coverage(candidate)

    info = {&#34;precision&#34;: candidate.precision, &#34;coverage&#34;: candidate.coverage}

    if self.smac_optim_func is not None:
        return self.smac_optim_func(candidate), info
    else:
        return (
            (
                (1 - candidate.precision)
                + (len(candidate.feature_mask) / self.sampler.num_features)
            )
            / 2,
            info,
        )</code></pre>
</details>
</dd>
<dt id="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self, anchor: Anchor.candidate.AnchorCandidate, instance: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualized the instance given the anchor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>anchor</code></strong> :&ensp;<code>AnchorCandidate</code></dt>
<dd>Anchor (usually result of explain_instance)</dd>
<dt><strong><code>instance</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Instance that shall be explained by the anchor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(self, anchor: AnchorCandidate, instance: np.ndarray):
    &#34;&#34;&#34;
    Visualized the instance given the anchor.

    Args:
        anchor (AnchorCandidate): Anchor (usually result of explain_instance)
        instance (np.ndarray): Instance that shall be explained by the anchor.
    &#34;&#34;&#34;

    # as text sampler has no self.features
    try:
        features = self.sampler.features
    except AttributeError:
        features = None

    return Visualizer.create(self.tasktype).visualize(anchor, instance, features)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor" href="index.html">iml-ws21-projects-risingnumpygods.Anchor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor">Anchor</a></code></h4>
<ul class="two-column">
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.coverage_data" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.coverage_data">coverage_data</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.explain_instance" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.explain_instance">explain_instance</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.generate_candidates" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.generate_candidates">generate_candidates</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.sampler" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.sampler">sampler</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.smac_optimize" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.smac_optimize">smac_optimize</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.tasktype" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.tasktype">tasktype</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.verbose" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.verbose">verbose</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualize" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualize">visualize</a></code></li>
<li><code><a title="iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualizer" href="#iml-ws21-projects-risingnumpygods.Anchor.anchor.Anchor.visualizer">visualizer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>